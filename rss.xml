<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>blog.zandr.me</title>
        <link>https://blog.zandr.me</link>
        <description></description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https://blog.zandr.me/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Sun, 09 Jun 2019 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>vimlfmt</title>
                <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
                <link>https://blog.zandr.me/vimlfmt/</link>
                <guid>https://blog.zandr.me/vimlfmt/</guid>
                <description>&lt;p&gt;I&#x27;ve just made public the repo for a project I&#x27;ve been working on for quite a while -
&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;deathlyfrantic&#x2f;vimlfmt&quot;&gt;vimlfmt&lt;&#x2f;a&gt;. vimlfmt is a code formatter for VimL (or VimScript) code, which is
the scripting language used by the Vim and Neovim text editors.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;background&quot;&gt;Background&lt;&#x2f;h2&gt;
&lt;p&gt;I love code formatters. It&#x27;s not that I&#x27;m unable to format code myself - I am, and I care a lot about this kind of
thing. But formatting code is a pretty mechanical task, and mechanical tasks should be done by machines. I&#x27;ve seen
arguments against using formatters suggesting that doing it manually is somehow more pure or virtuous, but I think that
idea is silly. Your editor indents your code as you type, doesn&#x27;t it? How is this different? Indeed, if all code
formatters did was indenting, I&#x27;d be ambivalent about the concept at best. But good formatters also deal with structure,
and that is where I see the value.&lt;&#x2f;p&gt;
&lt;p&gt;At work I write JavaScript almost exclusively, and &lt;a href=&quot;https:&#x2f;&#x2f;prettier.io&quot;&gt;Prettier&lt;&#x2f;a&gt; is godsend. Essentially all
JavaScript that does anything useful has some level of complicated nesting going on. Take this example:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;code&gt;const someVariable = someReallyLongFunctionName(foo, [bar, &amp;quot;baz&amp;quot;], { a: 1, b: 2, c: 3 }, err =&amp;gt; console.log(err));
&lt;&#x2f;code&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This line is 114 characters long, so if you&#x27;re trying to keep to 80- or 100-character columns, it has to be broken
somewhere. Where do you break it? You may have some general rule you try to follow, but do you always follow it
consistently, in every case? Prettier does. It does this (with &lt;code&gt;--parser babylon --trailing-comma es5&lt;&#x2f;code&gt;):&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;code&gt;const someVariable = someReallyLongFunctionName(
  foo,
  [bar, &amp;quot;baz&amp;quot;],
  { a: 1, b: 2, c: 3 },
  err =&amp;gt; console.log(err)
);
&lt;&#x2f;code&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;And it does so for everyone, in every case. Now I don&#x27;t have to go look for some other example that roughly matches the
shape of this code to see how it was formatted before. It&#x27;s just done and I can move on with my life. And our projects
have consistent formatting no matter who works on them!&lt;&#x2f;p&gt;
&lt;p&gt;Even easier, I use &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;sbdchd&#x2f;neoformat&quot;&gt;Neoformat&lt;&#x2f;a&gt; and have Neovim set up to run Neoformat on save - so
every time I write a buffer, the code is formatted for me automatically. It&#x27;s completely painless, and I&#x27;m so accustomed
to it I don&#x27;t even notice when it happens.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;vimlfmt&quot;&gt;vimlfmt&lt;&#x2f;h2&gt;
&lt;p&gt;Unfortunately, there was not a formatter for VimL code, or at least I was not able to find one. Since I (sadly) write a
fair amount of VimL, this was annoying. So, I decided I&#x27;d try to write one!&lt;&#x2f;p&gt;
&lt;p&gt;Since Rust has become my go-to language, I started there. I first toyed around with parsing VimL using a PEG parser
(specifically &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;kevinmehall&#x2f;rust-peg&quot;&gt;rust-peg&lt;&#x2f;a&gt;) but quickly ran into complications. First, I can&#x27;t
say I thoroughly understand how to use a PEG parser; second, VimL is a hilariously complicated monstrosity of a
language, and I don&#x27;t know if a PEG parser even &lt;em&gt;can&lt;&#x2f;em&gt; parse VimL.&lt;&#x2f;p&gt;
&lt;p&gt;I then stumbled across an existing VimL parser, &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;vim-jp&#x2f;vim-vimlparser&quot;&gt;vim-jp&#x2f;vim-vimlparser&lt;&#x2f;a&gt;, which
is written in VimL itself (and also has ports to Python and JavaScript in the repo). I decided it might be a fun project
to port this parser to Rust, &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;deathlyfrantic&#x2f;vimlfmt&#x2f;tree&#x2f;master&#x2f;parser&quot;&gt;which I did&lt;&#x2f;a&gt;, in a
more-or-less line-by-line fashion from the Python version. (I&#x27;ve since done some cleanup&#x2f;refactoring but it still very
much shows its roots as a translation.)&lt;&#x2f;p&gt;
&lt;p&gt;Once I had the parser basically working, I added a formatter layer on top, and the result is vimlfmt.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;viml-is-a-terrible-language&quot;&gt;VimL is a Terrible Language&lt;&#x2f;h2&gt;
&lt;p&gt;Once I had a basic skeleton of a formatter working, I set about to add the pieces necessary to do formatting beyond just
basic indentation and line-length stuff. This is when I came upon the realization that VimL is a terrible language. On
the surface, it&#x27;s basically Ruby- or Python-like - it&#x27;s dynamic, there are no curly braces, in general it&#x27;s pretty easy
to understand and read. Below that, however, it&#x27;s a mess.&lt;&#x2f;p&gt;
&lt;p&gt;The basic building block of VimL&#x27;s grammar&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt; is the expression, but to do almost anything useful, you need to use a
command. A command is either a built-in command (these start with lowercase letters, e.g. &lt;code&gt;echo&lt;&#x2f;code&gt;), or a user-defined
command (these must start with uppercase letters, e.g. &lt;code&gt;MyCommand&lt;&#x2f;code&gt;). This isn&#x27;t inherently bad, but let&#x27;s take a look at
an example which will illustrate one of the major pain points of parsing VimL.&lt;&#x2f;p&gt;
&lt;p&gt;Say you want to parse the &lt;code&gt;echo&lt;&#x2f;code&gt; command. If you look at &lt;code&gt;:help echo&lt;&#x2f;code&gt;, you&#x27;ll see that &lt;code&gt;echo&lt;&#x2f;code&gt; takes one or more &lt;code&gt;expr1&lt;&#x2f;code&gt;
arguments. (An &lt;code&gt;expr1&lt;&#x2f;code&gt; has a specific definition in VimL which I will not explain here, but &lt;code&gt;:help expr1&lt;&#x2f;code&gt; goes into
depth.) So we can pass a string literal to &lt;code&gt;echo&lt;&#x2f;code&gt;, or we can pass some more complicated expression which will be
evaluated before the result is then echoed. Thus,&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;3 + 2 =&amp;quot; 3 + 2
&lt;&#x2f;code&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;will echo &amp;quot;3 + 2 = 5&amp;quot;. Neat. This seems to make sense. A command is parsed as a name followed by some number of
space-separated expressions. Got it.&lt;&#x2f;p&gt;
&lt;p&gt;Now I want to change the way strings are highlighted, so I want to use the &lt;code&gt;highlight&lt;&#x2f;code&gt; command. Let&#x27;s figure out how it
works. Probably I just need to pass the expressions in a certain order, right? Problem #1: &lt;code&gt;:help highlight&lt;&#x2f;code&gt; doesn&#x27;t
take us directly to the &lt;code&gt;highlight&lt;&#x2f;code&gt; command; instead it takes us to the &amp;quot;Highlight command&amp;quot; section. Ok, scroll down,
find &lt;code&gt;:highlight&lt;&#x2f;code&gt;. At the time of this writing, the Neovim help lists &lt;em&gt;six&lt;&#x2f;em&gt; different forms of the &lt;code&gt;:highlight&lt;&#x2f;code&gt;
command:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;code&gt;:hi[ghlight]        List all the current highlight groups that have
                    attributes set.

:hi[ghlight] {group-name}
                    List one highlight group.

:hi[ghlight] clear  Reset all highlighting to the defaults.  Removes all
                    highlighting for groups added by the user!
                    Uses the current value of &#x27;background&#x27; to decide which
                    default colors to use.

:hi[ghlight] clear {group-name}
:hi[ghlight] {group-name} NONE
                    Disable the highlighting for one highlight group.  It
                    is _not_ set back to the default colors.

:hi[ghlight] [default] {group-name} {key}={arg} ..
                    Add a highlight group, or change the highlighting for
                    an existing group.
                    See highlight-args for the {key}={arg} arguments.
                    See :highlight-default for the optional [default]
                    argument.
&lt;&#x2f;code&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This one command does many different things depending on the arguments I pass to it. Not only that, but the arguments
aren&#x27;t expressions - they&#x27;re just raw strings. Some of them, like &lt;code&gt;clear&lt;&#x2f;code&gt;, are flags, some of them, like &lt;code&gt;{group-name}&lt;&#x2f;code&gt;,
are variables, some of them are key-value pairs (&lt;code&gt;{key}={arg}&lt;&#x2f;code&gt;). So if you want to parse &lt;code&gt;highlight&lt;&#x2f;code&gt; commands, you have
to recognize this command and parse its own weird syntax specifically. But it&#x27;s a command, just like &lt;code&gt;echo&lt;&#x2f;code&gt; - shouldn&#x27;t
the syntax be the same?&lt;&#x2f;p&gt;
&lt;p&gt;(Another fun thing, while we&#x27;re here - notice the &amp;quot;&lt;code&gt;hi[ghlight]&lt;&#x2f;code&gt;&amp;quot; in the help text there? What&#x27;s that about? Vim allows
you to abbreviate commands to the shortest-possible unique substring, so you can use &lt;code&gt;:hi&lt;&#x2f;code&gt; or &lt;code&gt;:hig&lt;&#x2f;code&gt; or &lt;code&gt;:high&lt;&#x2f;code&gt; or
&lt;code&gt;:highl&lt;&#x2f;code&gt; etc instead of typing out &lt;code&gt;:highlight&lt;&#x2f;code&gt;. This is presumably meant for usability when typing commands in the
command line, but unfortunately it means you have to match, in the case of &lt;code&gt;highlight&lt;&#x2f;code&gt;, eight different strings to a
single command. Different plugins use different conventions - personally I always try to use the full command name, but
&lt;a href=&quot;http:&#x2f;&#x2f;github.com&#x2f;ctrlpvim&#x2f;ctrlp.vim&quot;&gt;CtrlP&lt;&#x2f;a&gt; uses the shortest possible names, which I find basically unreadable.)&lt;&#x2f;p&gt;
&lt;p&gt;As we&#x27;ve just illustrated, parsing VimL commands is a huge pain. You need to account for every built-in command and its
unique syntax. Sure, some of them are the same: &lt;code&gt;echo&lt;&#x2f;code&gt;, &lt;code&gt;echon&lt;&#x2f;code&gt;, &lt;code&gt;echomsg&lt;&#x2f;code&gt;, and &lt;code&gt;echoerr&lt;&#x2f;code&gt; all use the same syntax
(though &lt;code&gt;echohl&lt;&#x2f;code&gt; doesn&#x27;t!), but &lt;code&gt;highlight&lt;&#x2f;code&gt; has six different forms by itself. (Good luck figuring out &lt;code&gt;:syntax&lt;&#x2f;code&gt;!)&lt;&#x2f;p&gt;
&lt;p&gt;In some cases, differing syntax for commands makes sense: &lt;code&gt;let&lt;&#x2f;code&gt;, which is used for variable declaration, understandably
has a different syntax than &lt;code&gt;while&lt;&#x2f;code&gt;, which is the command used to begin a while loop. But there should be an upper bound
on this variability. The current state is obviously a result of Vim&#x27;s long history, during which new functionality has
gradually been glommed on to the existing language, with little thought given to an overall design or consistency. Some
commands take arguments with sigils, e.g. &lt;code&gt;edit&lt;&#x2f;code&gt; takes options with a leading &lt;code&gt;++&lt;&#x2f;code&gt;, while others just take raw strings
as flags, e.g. our &lt;code&gt;highlight clear&lt;&#x2f;code&gt; example above, or &lt;code&gt;nested&lt;&#x2f;code&gt; in &lt;code&gt;autocmd&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;burnout&quot;&gt;Burnout&lt;&#x2f;h2&gt;
&lt;p&gt;The longer I worked on the formatter, the more frustrated I became by VimL&#x27;s weird quirks.&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt; This was partly
exacerbated by the fact that I was working in Rust, which (in my opinion) has a beautifully consistent design. I&#x27;d try
to implement formatting for a new command, and have to spend hours looking at the Vim help, working through all the
permutations. It was just exhausting.&lt;&#x2f;p&gt;
&lt;p&gt;Eventually I settled on making the parser dumber, and just parsing most commands as a name and a raw string for the
arguments. The idea is to move the parsing of the raw string of arguments into the consumer of the parsed tree (in
vimlfmt&#x27;s case, the formatter portion). So that&#x27;s where I&#x27;ve settled. But, I&#x27;m tired.&lt;&#x2f;p&gt;
&lt;p&gt;The fact is, I don&#x27;t write nearly the amount of VimL I once did - my Vim environment is more-or-less feature complete,
and my general tendency these days is to remove plugins, rather than to add them. With this just being a private
project to which only I was contributing, progress stalled and eventually stopped. I haven&#x27;t made significant changes to
the code in months. So this isn&#x27;t the perfect time to &amp;quot;release&amp;quot; the project, but without external motivation, further
progress is unlikely.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;contributions-wanted&quot;&gt;Contributions Wanted&lt;&#x2f;h2&gt;
&lt;p&gt;I&#x27;d love for vimlfmt to become useful for people, and for others to be excited about it. I&#x27;d especially love
contributions from folks who know how to write code formatters - I&#x27;m very much just winging it, and it&#x27;s entirely
possible the whole architecture of the project is terrible. If you would like to get involved, please do! Use it, see
what doesn&#x27;t work or what could work better, and submit an issue or PR.&lt;&#x2f;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2f;sup&gt;
&lt;p&gt;I am not a programming language grammarian, so please forgive my imprecise usage of this term.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2f;sup&gt;
&lt;p&gt;At some point I made a more-than-trivial effort to switch over to Emacs, just to have a more reasonable scripting
language. It didn&#x27;t work out, because Vim&#x27;s idioms are too ingrained in me to make such an effort worthwhile. (And
before you try to argue with me about this: yes, I used Evil mode. It&#x27;s not just modal keybindings for basic editing
that keeps me using Vim.)&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
</description>
            </item>
        
            <item>
                <title>A Failed Experiment in Data Structures</title>
                <pubDate>Sun, 19 Aug 2018 00:00:00 +0000</pubDate>
                <link>https://blog.zandr.me/charmap-data-structure-experiment/</link>
                <guid>https://blog.zandr.me/charmap-data-structure-experiment/</guid>
                <description>&lt;p&gt;I recently wrote &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;deathlyfrantic&#x2f;tack&quot;&gt;tack&lt;&#x2f;a&gt;, which is a recreation of &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;garybernhardt&#x2f;selecta&quot;&gt;Gary Bernhardt&#x27;s
Selecta&lt;&#x2f;a&gt; in C. Selecta is great, and there&#x27;s no reason not to use it. My
motivation for writing tack was the work itself; I wanted to implement a real tool in C and make it as fast as I
possibly could. I&#x27;ve accomplished my goal, at least for the time being: I don&#x27;t think I can make tack any faster without
using threads. I may eventually try that, but for now I&#x27;m calling it done.&lt;&#x2f;p&gt;
&lt;p&gt;In my search for speed, I tried an experiment with an interesting data structure. It didn&#x27;t quite work out, but it was a
fun journey.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;background&quot;&gt;Background&lt;&#x2f;h2&gt;
&lt;p&gt;Tack is a fuzzy finder. You dump some text into it through &lt;code&gt;stdin&lt;&#x2f;code&gt; and it opens up &lt;code&gt;&#x2f;dev&#x2f;tty&lt;&#x2f;code&gt; to display a UI which
allows you to search and filter the text. Once you&#x27;ve made a selection, tack outputs the line you chose to &lt;code&gt;stdout&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The search algorithm in tack comes directly from Selecta. Imagine searching for the query &lt;code&gt;imc&lt;&#x2f;code&gt; in the line &lt;code&gt;this is my sentence&lt;&#x2f;code&gt;. The search goes something like this:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;tack searches through each character in the line and looks for a match for the &lt;code&gt;i&lt;&#x2f;code&gt; - in this case, it finds the &lt;code&gt;i&lt;&#x2f;code&gt;
at position 2 (0-indexed)&lt;&#x2f;li&gt;
&lt;li&gt;if a match is found, it then looks for the &lt;code&gt;m&lt;&#x2f;code&gt;, starting from the letter after the &lt;code&gt;i&lt;&#x2f;code&gt; - in this case, starting from
position 3, it finds the &lt;code&gt;m&lt;&#x2f;code&gt; at position 8&lt;&#x2f;li&gt;
&lt;li&gt;if a match is found, it then looks for the &lt;code&gt;c&lt;&#x2f;code&gt;, starting from the letter after the &lt;code&gt;m&lt;&#x2f;code&gt; - in this case, starting from
position 9, it finds the &lt;code&gt;c&lt;&#x2f;code&gt; at position 17&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;The &amp;quot;score&amp;quot; for this match is 17 - 2 = 15.&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt; But we&#x27;re not done! Now, tack searches through each character in the line
&lt;em&gt;starting from position 3&lt;&#x2f;em&gt;, looking for a match for the &lt;code&gt;i&lt;&#x2f;code&gt;, and finds one at position 5. The remaining behavior is the
same, but this time our score ends up being 17 - 5 = 12. Tack continues in this fashion, trying to find the lowest
score, by starting a search from every &lt;code&gt;i&lt;&#x2f;code&gt; in the line. In this case, the lowest score is 12, so that&#x27;s the score we
use.&lt;&#x2f;p&gt;
&lt;p&gt;Every line is scanned in full at least once, searching for the first letter of the query, and then each sub-line is
scanned for every other letter in the query. The fastest scenario is the line contains none of the query letters - in
this case, we scan the line once and return &lt;code&gt;NULL&lt;&#x2f;code&gt; because there is no score. The second fastest scenario is the line
contains the first letter of the query, but none of the remaining - in this case, we scan the line once entirely, and
then once from the first letter match until the end, returning &lt;code&gt;NULL&lt;&#x2f;code&gt;. You can extrapolate the behavior. This can get
hairy if there are lots of matches and sub-lines to scan. I&#x27;m not great with big-O notation but I believe this is O(n
log n).&lt;&#x2f;p&gt;
&lt;p&gt;In our example, we looked at 47 characters:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;19 in the full line, searching for every &lt;code&gt;i&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;li&gt;15 in the first match, from the &lt;code&gt;s&lt;&#x2f;code&gt; after the first &lt;code&gt;i&lt;&#x2f;code&gt; to the &lt;code&gt;c&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;li&gt;13 in the second match, from the &lt;code&gt;s&lt;&#x2f;code&gt; after the second &lt;code&gt;i&lt;&#x2f;code&gt; to the &lt;code&gt;c&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;We found two matches of three characters each - so only six of the 47 were relevant. The rest were just wasted cycles.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-light-bulb&quot;&gt;The Light Bulb&lt;&#x2f;h2&gt;
&lt;p&gt;It seemed to me a lot of time is wasting looking at letters that &lt;em&gt;don&#x27;t&lt;&#x2f;em&gt; match; what if we could only search the letters
that do?&lt;&#x2f;p&gt;
&lt;p&gt;Imagine a data structure that looks something like this (shown in JSON for brevity):&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;t&amp;quot;: [0, 14],
    &amp;quot;h&amp;quot;: [1],
    &amp;quot;i&amp;quot;: [2, 5],
    &amp;quot;s&amp;quot;: [3, 6, 11],
    &amp;quot; &amp;quot;: [4, 7, 10],
    &amp;quot;m&amp;quot;: [8],
    &amp;quot;y&amp;quot;: [9],
    &amp;quot;e&amp;quot;: [12, 15, 18],
    &amp;quot;n&amp;quot;: [13, 16],
    &amp;quot;t&amp;quot;: [14],
    &amp;quot;c&amp;quot;: [17],
}
&lt;&#x2f;code&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Essentially, it&#x27;s a hash table of lists. With a structure like this, we could avoid characters we&#x27;re not searching for
entirely! Instead, we&#x27;d look for a key first, to determine whether there are &lt;em&gt;any&lt;&#x2f;em&gt; of the characters we want; if there
are, we can look at the positions of &lt;em&gt;just&lt;&#x2f;em&gt; that character to figure out if it is part of our match.&lt;&#x2f;p&gt;
&lt;p&gt;This time:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;we search for &lt;code&gt;i&lt;&#x2f;code&gt; in the keys of the table and find it is there, so we start our search at positions 2 and 5 (more
accurately 3 and 6)&lt;&#x2f;li&gt;
&lt;li&gt;we search for &lt;code&gt;m&lt;&#x2f;code&gt; in the keys of the table and find it is there - only one, at position 8; this works for both
matches&lt;&#x2f;li&gt;
&lt;li&gt;we search for &lt;code&gt;c&lt;&#x2f;code&gt; in the keys of the table and find it is there - only one, at position 17; this works for both
matches&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;We never had to look at any letter that wasn&#x27;t in our query! Instead of looking at 47 characters, we looked at 6.&lt;&#x2f;p&gt;
&lt;p&gt;Imagine searching this same line for &lt;code&gt;foo&lt;&#x2f;code&gt;: we immediately know &lt;code&gt;f&lt;&#x2f;code&gt; is not a key in our table, and we&#x27;re done. Instead
of the O(n) performance of iterating at every character in the line, instead we get O(1) performance from looking up a
key in a hash table.&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt; We did one hash table lookup, instead of looking at 19 entire characters.&lt;&#x2f;p&gt;
&lt;p&gt;Now imagine searching for &lt;code&gt;ce&lt;&#x2f;code&gt;: we find &lt;code&gt;c&lt;&#x2f;code&gt; in the table once, at position 17. We then search for &lt;code&gt;e&lt;&#x2f;code&gt;, find it in three
positions - but only one after our &lt;code&gt;c&lt;&#x2f;code&gt;, which is position 18. In this case we looked at one &lt;code&gt;c&lt;&#x2f;code&gt; and three &lt;code&gt;e&lt;&#x2f;code&gt;s - four
total characters, and they were all contained within our query.&lt;&#x2f;p&gt;
&lt;p&gt;Ultimately I decided to call this structure a &lt;code&gt;CharMap&lt;&#x2f;code&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;&#x2f;h2&gt;
&lt;p&gt;I thought this had to be worth trying, so I did. There&#x27;s a &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;deathlyfrantic&#x2f;tack&#x2f;tree&#x2f;charmap-experiment&quot;&gt;branch on
GitHub&lt;&#x2f;a&gt;. Most of the action is in
&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;deathlyfrantic&#x2f;tack&#x2f;blob&#x2f;charmap-experiment&#x2f;src&#x2f;charmap.c&quot;&gt;&lt;code&gt;charmap.c&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;. I used the existing hash
table implementation that I had already written to cache search results and then a growable array structure (very
similar to what I had already written to store other list data) to store the positions of each character.&lt;&#x2f;p&gt;
&lt;p&gt;Surprisingly, it worked! This is by far the most complicated data structure I&#x27;ve ever implemented in C, and I was
pleased with myself for how quickly I managed to get it working.&lt;&#x2f;p&gt;
&lt;p&gt;Unfortunately, it didn&#x27;t really help.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;&#x2f;h2&gt;
&lt;p&gt;When using the existing algorithm, this data structure &lt;em&gt;does&lt;&#x2f;em&gt; speed up searches. &lt;em&gt;However&lt;&#x2f;em&gt;, I hadn&#x27;t factored in the
cost of setting up these structures in the first place. In tack, that cost is amortized over the life of the process,
since the input lines are essentially immutable. I had figured whatever the penalty was of setting up these structures
would be well worth the speed increase of the searching, and it just wasn&#x27;t.&lt;&#x2f;p&gt;
&lt;p&gt;I didn&#x27;t specifically measure, but search speed was not noticeably faster. Start-up time, though, skyrocketed. What used
to be a barely perceptible flicker of a pause when starting up turned into a painfully obvious halt while all of the
structures were allocated and filled.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;trade-off&quot;&gt;Trade-off&lt;&#x2f;h2&gt;
&lt;p&gt;The general lifetime of a tack process is short. The idea is you dump some data in, enter a few characters to find the
line you want, maybe scroll up or down a few times, and hit enter. If you&#x27;re a fast typist and know what you&#x27;re looking
for, it may be running for less than a second total. In this context, the abysmal start-up time penalty imposed by the
&lt;code&gt;CharMap&lt;&#x2f;code&gt; structure was just too much to bear.&lt;&#x2f;p&gt;
&lt;p&gt;But, tack is generally used to operate on &amp;quot;short&amp;quot;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#4&quot;&gt;4&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt; lines. Searching a short line for a short query doesn&#x27;t offer as
much opportunity for optimization as searching a long line for a long query. Depending on the length of the lines and
the query, it may be entirely reasonable to endure the increased start-up cost to save a lot of time searching.&lt;&#x2f;p&gt;
&lt;p&gt;There&#x27;s probably a way to calculate the inflection point at which using this data structure makes sense, but I&#x27;m not
mathy enough to figure it out myself.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2f;h2&gt;
&lt;p&gt;While this experiment didn&#x27;t pan out, I still feel it was useful to perform. It took me out of my comfort zone and
forced me to stretch my abilities. In writing tack, not only have I really explored some complicated data structures,
I&#x27;ve also learned how to use lldb to debug C, and how to profile a running process using Instruments.app.&lt;&#x2f;p&gt;
&lt;p&gt;I&#x27;m not expecting anyone to switch from Selecta to tack. Unless you only need ASCII support and regularly search
hundreds of thousands of lines, the increased speed will not help you. For me, the whole point of writing tack in the
first place was learning. By that measure, it has been a very successful project.&lt;&#x2f;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2f;sup&gt;
&lt;p&gt;The scoring is a little more complicated than this, but this simplified version captures the gist of it.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2f;sup&gt;
&lt;p&gt;Hash tables only &lt;em&gt;average&lt;&#x2f;em&gt; O(1) performance, but in this case, since we&#x27;re only dealing with ASCII, I used 255
buckets in the hash table and the ordinal value of the character as the hash; this way I was guaranteed to avoid
collisions.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2f;sup&gt;
&lt;p&gt;I&#x27;m sure someone else has come up with something like this before and given it a better name.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;4&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2f;sup&gt;
&lt;p&gt;For some definition of &amp;quot;short.&amp;quot;&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
</description>
            </item>
        
            <item>
                <title>Email Address Completion in Vim</title>
                <pubDate>Sun, 19 Mar 2017 00:00:00 +0000</pubDate>
                <link>https://blog.zandr.me/vim-email-completion/</link>
                <guid>https://blog.zandr.me/vim-email-completion/</guid>
                <description>&lt;p&gt;A while back I somehow stumbled across &lt;a href=&quot;https:&#x2f;&#x2f;arp242.net&#x2f;code&#x2f;complete_email.vim&#x2f;&quot;&gt;this Vim utility&lt;&#x2f;a&gt; which provides a
completion function for email addresses. I really liked the idea, but I didn&#x27;t love the implementation; I don&#x27;t want to
create a new store for my contacts and I certainly don&#x27;t want to have to use a special escape character to separate the
fields in that store. Instead, I decided to reimplement the idea to suit my needs.&lt;&#x2f;p&gt;
&lt;p&gt;My Mutt configuration looks something like this:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;code&gt;$XDG_CONFIG_HOME&#x2f;mutt
├── aliases.muttrc
├── colors.muttrc
├── default.muttrc -&amp;gt; $XDG_CONFIG_HOME&#x2f;mutt&#x2f;account1.muttrc
├── account1.muttrc
├── account2.muttrc
├── mailcap
└── muttrc
&lt;&#x2f;code&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;I keep all of my configuration in &lt;code&gt;$XDG_CONFIG_HOME&#x2f;mutt&lt;&#x2f;code&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;, and I separate different concerns into separate files. My
main &lt;code&gt;muttrc&lt;&#x2f;code&gt; then &lt;code&gt;source&lt;&#x2f;code&gt;s the other files as appropriate. My aliases go in &lt;code&gt;aliases.muttrc&lt;&#x2f;code&gt;, colors in
&lt;code&gt;colors.muttrc&lt;&#x2f;code&gt;, etc. I keep account settings in separate files, and then link one of those account files to
&lt;code&gt;default.muttrc&lt;&#x2f;code&gt;, so that I can use different accounts by default on different machines.&lt;&#x2f;p&gt;
&lt;p&gt;The point of all that explanation is: I already store my contacts in &lt;code&gt;aliases.muttrc&lt;&#x2f;code&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;, which Mutt can read and
update, and which can be easily-parsed. The general format of a Mutt alias is:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;code&gt;alias foo Firstname Lastname &amp;lt;email@address.com&amp;gt;
&lt;&#x2f;code&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The pieces here are:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;alias&lt;&#x2f;code&gt; - this is the command itself&lt;&#x2f;li&gt;
&lt;li&gt;foo - this is the short name I would type in Mutt to identify a given alias&lt;&#x2f;li&gt;
&lt;li&gt;Firstname Lastname - really this is anything between the short name and the email address, but is generally a
contact&#x27;s proper name&lt;&#x2f;li&gt;
&lt;li&gt;&amp;lt;email@address.com&amp;gt; - the email address itself, enclosed in angle brackets&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Since this is a regular format&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;, it is easy to parse in a Vim completion function. Here&#x27;s the whole function, but the
parsing bit is only the last three lines:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;code&gt;function! emailcomplete#complete(findstart, base) abort
  if a:findstart
    &amp;quot; this portion finds and returns the starting
    &amp;quot; column of the word before the cursor
    let l:curpos = getcurpos()
    let l:pos = searchpos(&#x27;\s&#x27;, &#x27;b&#x27;)
    return (l:pos[0] == l:curpos[1]) ? l:pos[1] : 0
  endif
  &amp;quot; this portion finds aliases that contain the word
  &amp;quot; before the cursor and returns a list of them
  let aliases = readfile(expand(&#x27;$XDG_CONFIG_HOME&#x2f;mutt&#x2f;aliases.muttrc&#x27;))
  let emails = filter(aliases, {_, alias -&amp;gt; substitute(alias, &#x27;^alias &#x27;, &#x27;&#x27;, &#x27;&#x27;) =~? a:base})
  return map(copy(emails), {_, alias -&amp;gt; substitute(alias, &#x27;^alias \w\+ &#x27;, &#x27;&#x27;, &#x27;&#x27;)})
endfunction
&lt;&#x2f;code&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Basically: read in the &lt;code&gt;aliases.muttrc&lt;&#x2f;code&gt; file as a list; filter that list so that it only contains lines where the
portion &lt;em&gt;after&lt;&#x2f;em&gt; the &lt;code&gt;alias&lt;&#x2f;code&gt; command contains the matched string; return those results, but without the &lt;code&gt;alias shortname&lt;&#x2f;code&gt;
portion.&lt;&#x2f;p&gt;
&lt;p&gt;For example, let&#x27;s say I have this alias set up for my mom:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;code&gt;alias mom Firstname Lastname &amp;lt;firstname.lastname@mother.com&amp;gt;
&lt;&#x2f;code&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The above function will find this alias regardless of whether I type &amp;quot;firstname&amp;quot; or &amp;quot;mother&amp;quot; or &amp;quot;mom&amp;quot; or anything else
contained in the string &lt;code&gt;mom Firstname Lastname &amp;lt;firstname.lastname@mother.com&amp;gt;&lt;&#x2f;code&gt;. But, it only &lt;em&gt;returns&lt;&#x2f;em&gt; &lt;code&gt;Firstname Lastname &amp;lt;firstname.lastname@mother.com&amp;gt;&lt;&#x2f;code&gt;, not &lt;code&gt;mom&lt;&#x2f;code&gt;. So, my &lt;code&gt;To:&lt;&#x2f;code&gt; header goes from this:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;code&gt;To: mom
&lt;&#x2f;code&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;to this:&lt;&#x2f;p&gt;
&lt;pre&gt;&lt;code&gt;To: Firstname Lastname &amp;lt;firstname.lastname@mother.com&amp;gt;
&lt;&#x2f;code&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;If you want to use this function, but you&#x27;re unfamiliar with Vim completion, I&#x27;d recommend you read &lt;code&gt;:h ins-completion&lt;&#x2f;code&gt;.
That said, here&#x27;s a basic tl;dr:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;Save the above function in &lt;code&gt;$VIMHOME&#x2f;autoload&#x2f;emailcomplete.vim&lt;&#x2f;code&gt; (adjust the location of your aliases file as
necessary)&lt;&#x2f;li&gt;
&lt;li&gt;Add &lt;code&gt;setlocal completefunc=emailcomplete#complete&lt;&#x2f;code&gt; to &lt;code&gt;$VIMHOME&#x2f;ftplugin&#x2f;mail.vim&lt;&#x2f;code&gt; -or- add &lt;code&gt;autocmd FileType mail setlocal completefunc=emailcomplete#complete&lt;&#x2f;code&gt; to your &lt;code&gt;$MYVIMRC&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;li&gt;Press &lt;kbd&gt;&amp;lt;C-X&amp;gt;&amp;lt;C-U&amp;gt;&lt;&#x2f;kbd&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#4&quot;&gt;4&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt; in insert mode when you want to complete an email address in a mail file.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;Voilà!&lt;&#x2f;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2f;sup&gt;
&lt;p&gt;Mutt supports &lt;code&gt;$XDG_CONFIG_HOME&lt;&#x2f;code&gt; by default &lt;a href=&quot;http:&#x2f;&#x2f;www.mutt.org&#x2f;doc&#x2f;UPDATING&quot;&gt;as of version 1.8&lt;&#x2f;a&gt;. Hoorah!&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2f;sup&gt;
&lt;p&gt;Mutt has an &lt;a href=&quot;http:&#x2f;&#x2f;www.mutt.org&#x2f;doc&#x2f;manual&#x2f;#alias-file&quot;&gt;&lt;code&gt;$alias_file&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; variable you can set, which is the default
location where it will save aliases.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2f;sup&gt;
&lt;p&gt;The alias command does support &lt;a href=&quot;http:&#x2f;&#x2f;www.mutt.org&#x2f;doc&#x2f;manual&#x2f;#alias&quot;&gt;some other syntax&lt;&#x2f;a&gt;, but my usage of aliases
is pretty simple, so I only care about the basic syntax I explained.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;4&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2f;sup&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;Carpetsmoker&#x2f;complete_email.vim&quot;&gt;original implementation&lt;&#x2f;a&gt; uses
&lt;kbd&gt;&amp;lt;C-X&amp;gt;&amp;lt;C-M&amp;gt;&lt;&#x2f;kbd&gt; for triggering the completion, but I&#x27;m fine using the standard user completion keys
for this. It&#x27;s unlikely I&#x27;m going to have &lt;em&gt;another&lt;&#x2f;em&gt; custom completion function for the mail filetype.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
</description>
            </item>
        
            <item>
                <title>My Experience With The Kinesis Advantage2 Keyboard</title>
                <pubDate>Sun, 12 Feb 2017 00:00:00 +0000</pubDate>
                <link>https://blog.zandr.me/kinesis-advantage/</link>
                <guid>https://blog.zandr.me/kinesis-advantage/</guid>
                <description>&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;www.kinesis-ergo.com&#x2f;shop&#x2f;advantage2&#x2f;&quot;&gt;Kinesis Advantage2&lt;&#x2f;a&gt; is a bizarre spaceship keyboard that only
appeals to &lt;del&gt;über nerds&lt;&#x2f;del&gt; cool people who like maximizing efficiency of things that don&#x27;t even occur to the
general population. Also, sometimes people have RSI or wrist pain or whatever. I&#x27;m a member of the first group (of
cools) because I long-ago solved my wrist and hand pain with Microsoft ergonomic keyboards.&lt;&#x2f;p&gt;
&lt;p&gt;I don&#x27;t know when this post will be published. I wanted to start it now so I could document my journey of trying to use
this crazy keyboard. I received mine on January 23, 2017. For reference, my prior keyboard which I enjoyed quite a bit
was a Microsoft Sculpt. Before that I used the Microsoft 4000 and before that it was just regular cheapo Logitechs or
whatever.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;first-impressions-day-one-and-two&quot;&gt;First Impressions: Day One and Two&lt;&#x2f;h2&gt;
&lt;p&gt;It seems like a well-made device. I have not had a keyboard with mechanical switches in many years; this has Cherry
Browns which are supposed to be a something-something type of switch I&#x27;m not even going to pretend to care. (I am
purposely stopping myself from going down the key switch rabbit hole, because my other preferences are already weird and
specific enough.) Regardless of whatever specs, they feel nice.&lt;&#x2f;p&gt;
&lt;p&gt;I love the ability to remap keys on the keyboard itself. With my other keyboards I&#x27;ve resorted to &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;deathlyfrantic&#x2f;dotfiles&#x2f;blob&#x2f;af6f9af7923a98d11fa373f909efbfee52216b3c&#x2f;keyboard.hwdb&quot;&gt;custom udev
rules&lt;&#x2f;a&gt; to
remap &lt;kbd&gt;CapsLock&lt;&#x2f;kbd&gt; to &lt;kbd&gt;Ctrl&lt;&#x2f;kbd&gt;; here it&#x27;s a few keystrokes to do it. I also remapped some other keys:
swapped &lt;kbd&gt;Backspace&lt;&#x2f;kbd&gt; and regular &lt;kbd&gt;Space&lt;&#x2f;kbd&gt; (I&#x27;m a rare left-thumb spacer), assigned the &lt;kbd&gt;Logo&lt;&#x2f;kbd&gt;
key to &lt;kbd&gt;Delete&lt;&#x2f;kbd&gt;, &lt;kbd&gt;Alt&lt;&#x2f;kbd&gt; to &lt;kbd&gt;End&lt;&#x2f;kbd&gt;, &lt;kbd&gt;PageUp&lt;&#x2f;kbd&gt; to &lt;kbd&gt;Logo&lt;&#x2f;kbd&gt;, &lt;kbd&gt;PageDown&lt;&#x2f;kbd&gt; to
&lt;kbd&gt;PageUp&lt;&#x2f;kbd&gt;, &lt;kbd&gt;Esc&lt;&#x2f;kbd&gt; to &lt;kbd&gt;PageDown&lt;&#x2f;kbd&gt;, &lt;kbd&gt;CapsLock&lt;&#x2f;kbd&gt; to &lt;kbd&gt;Esc&lt;&#x2f;kbd&gt;, &lt;kbd&gt;Delete&lt;&#x2f;kbd&gt; to
left &lt;kbd&gt;Ctrl&lt;&#x2f;kbd&gt;, &lt;kbd&gt;End&lt;&#x2f;kbd&gt; to left &lt;kbd&gt;Alt&lt;&#x2f;kbd&gt;. Apparently the default layout really did not suit me.&lt;&#x2f;p&gt;
&lt;p&gt;The thumb clusters were a bit odd but I got used to them pretty quickly, actually. Within a few hours, using my thumbs
for &lt;kbd&gt;Backspace&lt;&#x2f;kbd&gt; and &lt;kbd&gt;Enter&lt;&#x2f;kbd&gt; became natural. In fact, the first time I used the keyboard on my laptop
(within a few hours of getting the Advantage2), I was trying to backspace with my thumb. It seems like a very natural
motion.&lt;&#x2f;p&gt;
&lt;p&gt;Unfortunately I am not having as much luck adapting to the rest of the keyboard. I am mostly to the point where I can
type letters ok. About an hour after I got the keyboard I played a game of &lt;a href=&quot;http:&#x2f;&#x2f;play.typeracer.com&#x2f;&quot;&gt;TypeRacer&lt;&#x2f;a&gt; and
scored 35wpm with about 87% accuracy. A day later I&#x27;m up to 67wpm with 91% accuracy. (For reference, I generally type in
the 100-120wpm range with accuracy in the high 90s.) I have no doubt that&#x27;s going to continue to improve. I guess my
typing technique is pretty bad - I generally only use three fingers (first, middle and ring) on each hand - and the
Advantage2 is very unforgiving of that. So I&#x27;m gradually improving my technique and eventually I&#x27;ll be as fast as I was.&lt;&#x2f;p&gt;
&lt;p&gt;The thing that is very inconvenient is the location of punctuation and control keys. I&#x27;m a programmer, and punctuation
is a big part of doing my job (even in languages that don&#x27;t use a ton of it, like Python). To make the Advantage2 fit
into a small space, a lot of the keys commonly used in programming were moved to different places - the &lt;kbd&gt;+&#x2f;=&lt;&#x2f;kbd&gt;
key, for example, is where the &lt;kbd&gt;~&lt;&#x2f;kbd&gt; key is normally. The &lt;kbd&gt;~&lt;&#x2f;kbd&gt; key is below the &lt;kbd&gt;Z&lt;&#x2f;kbd&gt; (or
&lt;kbd&gt;:&lt;&#x2f;kbd&gt; in Dvorak), which is not a space where I&#x27;m accustomed to having a key. The brackets are possibly the worst
part. They are below the &lt;kbd&gt;&amp;gt;&lt;&#x2f;kbd&gt; and &lt;kbd&gt;?&lt;&#x2f;kbd&gt; keys and it&#x27;s essentially impossible for me to press them without
looking yet. I also have a lot of trouble hitting the correct parenthesis keys - I tend to hit &lt;kbd&gt;*&lt;&#x2f;kbd&gt; when I want
&lt;kbd&gt;(&lt;&#x2f;kbd&gt; and &lt;kbd&gt;(&lt;&#x2f;kbd&gt; when I want &lt;kbd&gt;)&lt;&#x2f;kbd&gt;. And the arrow keys, which as a Vim user are not at all important
to me generally, keep getting in my way. It&#x27;s about 50&#x2f;50 whether I hit &lt;kbd&gt;C&lt;&#x2f;kbd&gt; or &lt;kbd&gt;→&lt;&#x2f;kbd&gt;; I often end up
with the cursor in the middle of a word I&#x27;m typing. However, when I then try to correct that word, by using
&lt;kbd&gt;←&lt;&#x2f;kbd&gt;, I have to look to find it.&lt;&#x2f;p&gt;
&lt;p&gt;This is the part that worries me about the Advantage2. I accept that my technique will get better and I&#x27;ll adjust to
words ok because I&#x27;ve already seen improvements. But punctuation keys are so important for my profession and I have yet
to see any progress on getting them down. I&#x27;m as bad with brackets now as I was yesterday despite hours of use. And if I
can&#x27;t manage to adjust, there&#x27;s no way I&#x27;ll be able to stick with the Advantage2.&lt;&#x2f;p&gt;
&lt;p&gt;Another weird thing is that despite the general impression that the keyboard &lt;em&gt;can&lt;&#x2f;em&gt; relieve pain (I know this is not
proven and Kinesis does not make any claims to this effect), I&#x27;m actually experiencing a noticeable amount of pain on
the tops of my hands in the area of the tendons. I believe this may be related to the upward angle of the keyboard,
which is not adjustable. The Sculpt slopes downward from the back. But perhaps that is because I have had to change my
typing technique and I am now using my muscles in a way I am not accustomed to. This could also be a combination of the
setup of my desk and chair, or my posture, or any number of other factors. So I&#x27;m not saying the Advantage2 is &lt;em&gt;causing&lt;&#x2f;em&gt;
this, just that something is and I may need to make other adjustments to use it effectively.&lt;&#x2f;p&gt;
&lt;p&gt;At this point, I do like the keyboard in general, but it&#x27;s going to require much more adaptation on my part than I had
anticipated. When I first switched to the 4000 from a traditional keyboard I could pretty much type at my full speed
within a few hours. I naïvely expected the same type of transition in this case. That was mistake on my part. (Kinesis
says most users adapt within 2-4 &lt;em&gt;weeks&lt;&#x2f;em&gt;.)&lt;&#x2f;p&gt;
&lt;h2 id=&quot;day-3-continuum&quot;&gt;Day 3: Continuum&lt;&#x2f;h2&gt;
&lt;p&gt;I thought a lot about the Advantage2 as I was trying to get to sleep last night (because I am cool), and came upon the
realization that it might not be for me. My aforementioned &amp;quot;bad&amp;quot; typing technique may not actually be bad, per se;
perhaps it&#x27;s just &lt;em&gt;different&lt;&#x2f;em&gt;. Thinking about it, my hands tend to move a lot when I type on a more conventional
keyboard, and the Advantage2 is really designed for zero (or minimal) hand movement. That caused a lot of adaptation
friction for me.&lt;&#x2f;p&gt;
&lt;p&gt;And is the technique the Advantage2 imposes upon the user necessarily better? Maybe for some, or even most; but I&#x27;ve
been typing this way for 30-ish years, and forgive me for sounding like a 65-year-old chain smoker, but it hasn&#x27;t hurt
me yet.&lt;&#x2f;p&gt;
&lt;p&gt;That point is, I think, important. Because after two days with the Advantage2, I was experiencing hand and wrist pain. I
am not saying the Advantage2 was the direct cause - it&#x27;s just as likely my posture when sitting at my desk does not mesh
well with its shape - but ergonomics are not an exact science and what works for most will not necessarily work for all.
What I &lt;em&gt;am&lt;&#x2f;em&gt; saying, though, is my entire setup worked fine, and when I switched to the Advantage2 from the Sculpt, it
stopped working fine.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;day-uh-20-i-guess-it-s-over&quot;&gt;Day, uh, 20, I guess?: It&#x27;s Over&lt;&#x2f;h2&gt;
&lt;p&gt;Oh gosh, I nearly forgot about my experiment with the Advantage2 entirely. I sent it back on the fourth day of having
it. It just wasn&#x27;t going to work for me. The mechanical switches were great, and I miss them a bit, but otherwise I&#x27;m
happy with my Sculpt. Having a semi-normal key layout is far more important to me than I realized. I&#x27;m currently eyeing
the &lt;a href=&quot;http:&#x2f;&#x2f;matias.ca&#x2f;ergopro&#x2f;pc&#x2f;&quot;&gt;Matias Ergo Pro&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;final-kinesis-advantage2-tl-dr-review&quot;&gt;Final Kinesis Advantage2 tl;dr Review&lt;&#x2f;h2&gt;
&lt;p&gt;A well-made, nice keyboard with great switches that may not be for you.&lt;&#x2f;p&gt;
</description>
            </item>
        
    </channel>
</rss>
